/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Supabase type generation issues
/**
 * Ideas API Route
 *
 * GET /api/ideas — Fetch recent idea sparks from email analyses
 * POST /api/ideas — Save an idea from the sparks to the email_ideas table
 * PATCH /api/ideas — Update an idea's status (save, dismiss, done)
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * NEW (FEB 2026): Creative Idea Generation from Email Content
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Ideas are generated by the IdeaSparkAnalyzer during email processing and
 * stored in email_analyses.idea_sparks JSONB. This endpoint reads those sparks
 * and returns them for display.
 *
 * When a user saves/stars an idea, it's promoted to the email_ideas table
 * via the POST endpoint for persistent tracking.
 *
 * @module app/api/ideas/route
 * @since February 2026
 */

import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';
import { createLogger } from '@/lib/utils/logger';

const logger = createLogger('IdeasAPI');

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * A spark idea extracted from email_analyses.idea_sparks JSONB.
 */
interface SparkIdea {
  /** The idea text */
  idea: string;
  /** Category: social_post, networking, business, etc. */
  type: string;
  /** Why this connects to the user */
  relevance: string;
  /** Confidence score 0-1 */
  confidence: number;
  /** Source email ID */
  emailId: string;
  /** Source email subject (for context) */
  emailSubject: string | null;
  /** Source email sender */
  emailSender: string | null;
  /** When the email was analyzed */
  analyzedAt: string;
}

// ═══════════════════════════════════════════════════════════════════════════════
// GET — Fetch recent idea sparks
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * GET /api/ideas
 *
 * Returns recent idea sparks from email analyses.
 *
 * Query params:
 * - limit: Number of emails to check for ideas (default: 10, max: 30)
 * - type: Filter by idea type (e.g., 'social_post', 'networking')
 * - min_confidence: Minimum confidence threshold (default: 0.3)
 *
 * Response: Array of spark ideas with source email context
 */
export async function GET(request: NextRequest) {
  const startTime = Date.now();

  try {
    // ─── Authentication ──────────────────────────────────────────────────
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      logger.warn('Unauthorized ideas request');
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // ─── Parse query params ──────────────────────────────────────────────
    const { searchParams } = new URL(request.url);
    const limitParam = searchParams.get('limit');
    const limit = Math.min(Math.max(parseInt(limitParam || '10', 10), 1), 30);
    const typeFilter = searchParams.get('type');
    const minConfidence = parseFloat(searchParams.get('min_confidence') || '0.3');

    logger.start('Fetching idea sparks', {
      userId: user.id.substring(0, 8),
      limit,
      typeFilter,
      minConfidence,
    });

    // ─── Fetch recent analyses with idea_sparks ──────────────────────────
    // Join with emails to get subject/sender context
    const { data: analyses, error: queryError } = await supabase
      .from('email_analyses')
      .select(`
        email_id,
        idea_sparks,
        created_at,
        emails!inner (
          id,
          subject,
          sender_name,
          sender_email,
          signal_strength
        )
      `)
      .eq('user_id', user.id)
      .not('idea_sparks', 'is', null)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (queryError) {
      logger.error('Ideas query failed', {
        error: queryError.message,
        code: queryError.code,
      });
      return NextResponse.json(
        { error: 'Failed to fetch ideas', details: queryError.message },
        { status: 500 }
      );
    }

    // ─── Extract and flatten spark ideas ─────────────────────────────────
    const sparkIdeas: SparkIdea[] = [];

    for (const analysis of (analyses || [])) {
      const sparks = analysis.idea_sparks as {
        has_ideas?: boolean;
        ideas?: Array<{
          idea: string;
          type: string;
          relevance: string;
          confidence: number;
        }>;
      } | null;

      if (!sparks?.has_ideas || !sparks.ideas) continue;

      const email = analysis.emails as {
        id: string;
        subject: string | null;
        sender_name: string | null;
        sender_email: string;
        signal_strength: string | null;
      };

      for (const spark of sparks.ideas) {
        // Apply confidence filter
        if (spark.confidence < minConfidence) continue;

        // Apply type filter
        if (typeFilter && spark.type !== typeFilter) continue;

        sparkIdeas.push({
          idea: spark.idea,
          type: spark.type,
          relevance: spark.relevance,
          confidence: spark.confidence,
          emailId: email.id,
          emailSubject: email.subject,
          emailSender: email.sender_name || email.sender_email,
          analyzedAt: analysis.created_at,
        });
      }
    }

    // Sort by confidence (highest first), then by recency
    sparkIdeas.sort((a, b) => {
      if (Math.abs(b.confidence - a.confidence) > 0.1) {
        return b.confidence - a.confidence;
      }
      return new Date(b.analyzedAt).getTime() - new Date(a.analyzedAt).getTime();
    });

    // ─── Fetch saved ideas count ─────────────────────────────────────────
    const { count: savedCount } = await supabase
      .from('email_ideas')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .neq('status', 'dismissed');

    // ─── Build stats ─────────────────────────────────────────────────────
    const typeCounts: Record<string, number> = {};
    for (const idea of sparkIdeas) {
      typeCounts[idea.type] = (typeCounts[idea.type] || 0) + 1;
    }

    const stats = {
      totalSparks: sparkIdeas.length,
      savedIdeas: savedCount ?? 0,
      byType: typeCounts,
      avgConfidence: sparkIdeas.length > 0
        ? Math.round((sparkIdeas.reduce((sum, i) => sum + i.confidence, 0) / sparkIdeas.length) * 100) / 100
        : 0,
    };

    logger.success('Idea sparks fetched', {
      userId: user.id.substring(0, 8),
      sparkCount: sparkIdeas.length,
      savedCount: savedCount ?? 0,
      processingTimeMs: Date.now() - startTime,
    });

    return NextResponse.json({
      items: sparkIdeas,
      stats,
      lastUpdated: new Date().toISOString(),
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error('Ideas fetch failed', { error: errorMessage });
    return NextResponse.json(
      { error: 'Failed to fetch ideas', details: errorMessage },
      { status: 500 }
    );
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// POST — Save an idea to the email_ideas table
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * POST /api/ideas
 *
 * Saves an idea from the sparks to the email_ideas table.
 * This "promotes" a generated idea to a user-tracked item.
 *
 * Body:
 * - idea: string — the idea text
 * - ideaType: string — category (social_post, networking, etc.)
 * - relevance: string — why it's relevant
 * - confidence: number — confidence score
 * - emailId: string — source email ID (optional)
 *
 * Response: The created email_ideas record
 */
export async function POST(request: NextRequest) {
  try {
    // ─── Authentication ──────────────────────────────────────────────────
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // ─── Parse body ──────────────────────────────────────────────────────
    const body = await request.json();
    const { idea, ideaType, relevance, confidence, emailId } = body;

    if (!idea || !ideaType) {
      return NextResponse.json(
        { error: 'idea and ideaType are required' },
        { status: 400 }
      );
    }

    logger.info('Saving idea', {
      userId: user.id.substring(0, 8),
      ideaType,
      emailId: emailId?.substring(0, 8) ?? null,
      ideaPreview: idea.substring(0, 50),
    });

    // ─── Insert into email_ideas ─────────────────────────────────────────
    const { data: savedIdea, error: insertError } = await supabase
      .from('email_ideas')
      .insert({
        user_id: user.id,
        email_id: emailId || null,
        idea,
        idea_type: ideaType,
        relevance: relevance || null,
        confidence: confidence || null,
        status: 'saved',
      })
      .select()
      .single();

    if (insertError) {
      logger.error('Failed to save idea', {
        error: insertError.message,
        code: insertError.code,
      });
      return NextResponse.json(
        { error: 'Failed to save idea', details: insertError.message },
        { status: 500 }
      );
    }

    logger.success('Idea saved', {
      ideaId: savedIdea.id.substring(0, 8),
      ideaType,
    });

    return NextResponse.json({ success: true, data: savedIdea }, { status: 201 });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error('Idea save failed', { error: errorMessage });
    return NextResponse.json(
      { error: 'Failed to save idea', details: errorMessage },
      { status: 500 }
    );
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PATCH — Update an idea's status
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * PATCH /api/ideas
 *
 * Updates an idea's status (new → saved, saved → done, etc.)
 *
 * Body:
 * - id: string — the email_ideas record ID
 * - status: 'new' | 'saved' | 'dismissed' | 'done'
 */
export async function PATCH(request: NextRequest) {
  try {
    // ─── Authentication ──────────────────────────────────────────────────
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // ─── Parse body ──────────────────────────────────────────────────────
    const body = await request.json();
    const { id, status } = body;

    if (!id || !status) {
      return NextResponse.json(
        { error: 'id and status are required' },
        { status: 400 }
      );
    }

    const validStatuses = ['new', 'saved', 'dismissed', 'done'];
    if (!validStatuses.includes(status)) {
      return NextResponse.json(
        { error: `status must be one of: ${validStatuses.join(', ')}` },
        { status: 400 }
      );
    }

    logger.info('Updating idea status', {
      ideaId: id.substring(0, 8),
      newStatus: status,
    });

    // ─── Update ──────────────────────────────────────────────────────────
    const { error: updateError } = await supabase
      .from('email_ideas')
      .update({ status, updated_at: new Date().toISOString() })
      .eq('id', id)
      .eq('user_id', user.id);

    if (updateError) {
      logger.error('Failed to update idea', {
        ideaId: id.substring(0, 8),
        error: updateError.message,
      });
      return NextResponse.json(
        { error: 'Failed to update idea', details: updateError.message },
        { status: 500 }
      );
    }

    logger.success('Idea status updated', { ideaId: id.substring(0, 8), status });

    return NextResponse.json({ success: true });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error('Idea update failed', { error: errorMessage });
    return NextResponse.json(
      { error: 'Failed to update idea', details: errorMessage },
      { status: 500 }
    );
  }
}
