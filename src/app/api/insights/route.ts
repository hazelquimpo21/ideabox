/**
 * Insights API Route
 *
 * Endpoints for fetching synthesized insights from email analyses
 * and saving user-promoted insights.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * NEW (FEB 2026): Insight Extraction from Email Content
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * GET  /api/insights - Fetch recent insights from email analyses
 * POST /api/insights - Save an insight to the saved_insights table
 * PATCH /api/insights - Update insight status (saved/dismissed/archived)
 *
 * ARCHITECTURE:
 * - Insights are generated by InsightExtractorAnalyzer during email processing
 * - Stored transiently in email_analyses.insight_extraction JSONB
 * - When user saves an insight, it's promoted to the saved_insights table
 * - GET reads from email_analyses (transient) for the feed view
 * - POST/PATCH operate on saved_insights (persistent)
 *
 * @module app/api/insights
 * @since February 2026
 */

import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';
import { createLogger } from '@/lib/utils/logger';

const logger = createLogger('api/insights');

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Shape of the insight_extraction JSONB stored in email_analyses.
 */
interface InsightExtractionJsonb {
  has_insights: boolean;
  insights: Array<{
    insight: string;
    type: string;
    topics: string[];
    confidence: number;
  }>;
  confidence: number;
}

// ═══════════════════════════════════════════════════════════════════════════════
// GET /api/insights - Fetch recent insights from email analyses
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Fetches recent insights from email_analyses.insight_extraction.
 *
 * Query params:
 * - limit: Number of emails to check (1-30, default 10)
 * - type: Filter by insight type (tip, framework, observation, counterintuitive, trend)
 * - min_confidence: Minimum confidence threshold (default 0.3)
 *
 * Response:
 * ```json
 * {
 *   "items": [...InsightItem],
 *   "stats": {
 *     "totalInsights": number,
 *     "savedInsights": number,
 *     "byType": { "tip": 3, "trend": 2, ... },
 *     "avgConfidence": number
 *   },
 *   "lastUpdated": "ISO string"
 * }
 * ```
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Parse query params
    const searchParams = request.nextUrl.searchParams;
    const limit = Math.min(30, Math.max(1, parseInt(searchParams.get('limit') || '10', 10)));
    const typeFilter = searchParams.get('type') || '';
    const minConfidence = parseFloat(searchParams.get('min_confidence') || '0.3');

    logger.debug('Fetching insights', { userId: user.id.substring(0, 8), limit, typeFilter, minConfidence });

    // Fetch recent email analyses that have insight_extraction data
    const { data: analyses, error: fetchError } = await supabase
      .from('email_analyses')
      .select(`
        email_id,
        insight_extraction,
        created_at,
        emails!inner (
          id,
          subject,
          sender_name,
          sender_email
        )
      `)
      .eq('user_id', user.id)
      .not('insight_extraction', 'is', null)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (fetchError) {
      logger.error('Failed to fetch insights', { error: fetchError.message });
      return NextResponse.json({ error: 'Failed to fetch insights' }, { status: 500 });
    }

    // Flatten insights from all analyses into a single list
    const items: Array<{
      insight: string;
      type: string;
      topics: string[];
      confidence: number;
      emailId: string;
      emailSubject: string | null;
      emailSender: string | null;
      analyzedAt: string;
    }> = [];

    const byType: Record<string, number> = {};
    let totalConfidence = 0;
    let insightCount = 0;

    for (const analysis of analyses || []) {
      const extraction = analysis.insight_extraction as InsightExtractionJsonb | null;
      if (!extraction?.has_insights || !extraction.insights?.length) continue;

      const email = analysis.emails as unknown as {
        id: string;
        subject: string | null;
        sender_name: string | null;
        sender_email: string | null;
      };

      for (const insight of extraction.insights) {
        // Apply confidence filter
        if (insight.confidence < minConfidence) continue;

        // Apply type filter
        if (typeFilter && insight.type !== typeFilter) continue;

        items.push({
          insight: insight.insight,
          type: insight.type,
          topics: insight.topics || [],
          confidence: insight.confidence,
          emailId: analysis.email_id,
          emailSubject: email?.subject ?? null,
          emailSender: email?.sender_name || email?.sender_email || null,
          analyzedAt: analysis.created_at,
        });

        // Track stats
        byType[insight.type] = (byType[insight.type] || 0) + 1;
        totalConfidence += insight.confidence;
        insightCount++;
      }
    }

    // Get count of user's saved insights
    const { count: savedCount } = await supabase
      .from('saved_insights')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('status', 'saved');

    const stats = {
      totalInsights: insightCount,
      savedInsights: savedCount ?? 0,
      byType,
      avgConfidence: insightCount > 0
        ? Math.round((totalConfidence / insightCount) * 100) / 100
        : 0,
    };

    logger.debug('Insights fetched', {
      itemCount: items.length,
      totalInsights: insightCount,
      savedInsights: savedCount ?? 0,
    });

    return NextResponse.json({
      items,
      stats,
      lastUpdated: analyses?.[0]?.created_at || null,
    });
  } catch (error) {
    logger.error('Insights API error', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// POST /api/insights - Save an insight to saved_insights table
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Saves an insight to the saved_insights table.
 * Promotes a transient insight from email_analyses to persistent storage.
 *
 * Body:
 * ```json
 * {
 *   "insight": "string",
 *   "insightType": "tip|framework|observation|counterintuitive|trend",
 *   "topics": ["string"],
 *   "confidence": 0.85,
 *   "emailId": "uuid"
 * }
 * ```
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { insight, insightType, topics, confidence, emailId } = body;

    // Validate required fields
    if (!insight || !insightType) {
      return NextResponse.json(
        { error: 'Missing required fields: insight, insightType' },
        { status: 400 }
      );
    }

    logger.info('Saving insight', {
      userId: user.id.substring(0, 8),
      insightType,
      emailId: emailId?.substring(0, 8),
      preview: insight.substring(0, 40),
    });

    const { data, error: insertError } = await supabase
      .from('saved_insights')
      .insert({
        user_id: user.id,
        email_id: emailId || null,
        insight,
        insight_type: insightType,
        topics: topics || [],
        status: 'saved',
        confidence: confidence || null,
      })
      .select('id')
      .single();

    if (insertError) {
      logger.error('Failed to save insight', { error: insertError.message });
      return NextResponse.json({ error: 'Failed to save insight' }, { status: 500 });
    }

    logger.info('Insight saved', { id: data.id, insightType });

    return NextResponse.json({ success: true, id: data.id }, { status: 201 });
  } catch (error) {
    logger.error('Save insight error', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PATCH /api/insights - Update insight status
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Updates the status of a saved insight.
 *
 * Body:
 * ```json
 * {
 *   "id": "uuid",
 *   "status": "new|saved|dismissed|archived"
 * }
 * ```
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { id, status } = body;

    if (!id || !status) {
      return NextResponse.json(
        { error: 'Missing required fields: id, status' },
        { status: 400 }
      );
    }

    const validStatuses = ['new', 'saved', 'dismissed', 'archived'];
    if (!validStatuses.includes(status)) {
      return NextResponse.json(
        { error: `Invalid status. Must be one of: ${validStatuses.join(', ')}` },
        { status: 400 }
      );
    }

    logger.info('Updating insight status', {
      insightId: id.substring(0, 8),
      newStatus: status,
    });

    const { error: updateError } = await supabase
      .from('saved_insights')
      .update({
        status,
        updated_at: new Date().toISOString(),
      })
      .eq('id', id)
      .eq('user_id', user.id); // Ownership check

    if (updateError) {
      logger.error('Failed to update insight', { error: updateError.message });
      return NextResponse.json({ error: 'Failed to update insight' }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    logger.error('Update insight error', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
