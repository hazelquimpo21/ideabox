/**
 * News API Route
 *
 * Endpoints for fetching extracted news items from email analyses
 * and saving user-promoted news.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * NEW (FEB 2026): Factual News Extraction from Email Content
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * GET  /api/news - Fetch recent news items from email analyses
 * POST /api/news - Save a news item to the saved_news table
 * PATCH /api/news - Update news item status (saved/dismissed/archived)
 *
 * ARCHITECTURE:
 * - News items are generated by NewsBriefAnalyzer during email processing
 * - Stored transiently in email_analyses.news_brief JSONB
 * - When user saves a news item, it's promoted to the saved_news table
 * - GET reads from email_analyses (transient) for the feed view
 * - POST/PATCH operate on saved_news (persistent)
 *
 * @module app/api/news
 * @since February 2026
 */

import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';
import { createLogger } from '@/lib/utils/logger';

const logger = createLogger('api/news');

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Shape of the news_brief JSONB stored in email_analyses.
 */
interface NewsBriefJsonb {
  has_news: boolean;
  news_items: Array<{
    headline: string;
    detail: string;
    topics: string[];
    date_mentioned?: string;
    confidence: number;
  }>;
  confidence: number;
}

// ═══════════════════════════════════════════════════════════════════════════════
// GET /api/news - Fetch recent news items from email analyses
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Fetches recent news items from email_analyses.news_brief.
 *
 * Query params:
 * - limit: Number of emails to check (1-30, default 10)
 * - topic: Filter by topic tag
 * - min_confidence: Minimum confidence threshold (default 0.3)
 *
 * Response:
 * ```json
 * {
 *   "items": [...NewsItemDisplay],
 *   "stats": {
 *     "totalNews": number,
 *     "savedNews": number,
 *     "topTopics": [{ topic: string, count: number }],
 *     "avgConfidence": number
 *   },
 *   "lastUpdated": "ISO string"
 * }
 * ```
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Parse query params
    const searchParams = request.nextUrl.searchParams;
    const limit = Math.min(30, Math.max(1, parseInt(searchParams.get('limit') || '10', 10)));
    const topicFilter = searchParams.get('topic') || '';
    const minConfidence = parseFloat(searchParams.get('min_confidence') || '0.3');

    logger.debug('Fetching news items', { userId: user.id.substring(0, 8), limit, topicFilter, minConfidence });

    // Fetch recent email analyses that have news_brief data
    const { data: analyses, error: fetchError } = await supabase
      .from('email_analyses')
      .select(`
        email_id,
        news_brief,
        created_at,
        emails!inner (
          id,
          subject,
          sender_name,
          sender_email
        )
      `)
      .eq('user_id', user.id)
      .not('news_brief', 'is', null)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (fetchError) {
      logger.error('Failed to fetch news', { error: fetchError.message });
      return NextResponse.json({ error: 'Failed to fetch news' }, { status: 500 });
    }

    // Flatten news items from all analyses into a single list
    const items: Array<{
      headline: string;
      detail: string;
      topics: string[];
      dateMentioned: string | null;
      confidence: number;
      emailId: string;
      emailSubject: string | null;
      emailSender: string | null;
      analyzedAt: string;
    }> = [];

    const topicCounts: Record<string, number> = {};
    let totalConfidence = 0;
    let newsCount = 0;

    for (const analysis of analyses || []) {
      const brief = analysis.news_brief as NewsBriefJsonb | null;
      if (!brief?.has_news || !brief.news_items?.length) continue;

      const email = analysis.emails as unknown as {
        id: string;
        subject: string | null;
        sender_name: string | null;
        sender_email: string | null;
      };

      for (const newsItem of brief.news_items) {
        // Apply confidence filter
        if (newsItem.confidence < minConfidence) continue;

        // Apply topic filter
        if (topicFilter && !newsItem.topics?.includes(topicFilter)) continue;

        items.push({
          headline: newsItem.headline,
          detail: newsItem.detail,
          topics: newsItem.topics || [],
          dateMentioned: newsItem.date_mentioned || null,
          confidence: newsItem.confidence,
          emailId: analysis.email_id,
          emailSubject: email?.subject ?? null,
          emailSender: email?.sender_name || email?.sender_email || null,
          analyzedAt: analysis.created_at,
        });

        // Track topic stats
        for (const topic of newsItem.topics || []) {
          topicCounts[topic] = (topicCounts[topic] || 0) + 1;
        }
        totalConfidence += newsItem.confidence;
        newsCount++;
      }
    }

    // Get count of user's saved news items
    const { count: savedCount } = await supabase
      .from('saved_news')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('status', 'saved');

    // Build top topics list sorted by count
    const topTopics = Object.entries(topicCounts)
      .map(([topic, count]) => ({ topic, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    const stats = {
      totalNews: newsCount,
      savedNews: savedCount ?? 0,
      topTopics,
      avgConfidence: newsCount > 0
        ? Math.round((totalConfidence / newsCount) * 100) / 100
        : 0,
    };

    logger.debug('News items fetched', {
      itemCount: items.length,
      totalNews: newsCount,
      savedNews: savedCount ?? 0,
      topTopics: topTopics.slice(0, 3).map(t => t.topic),
    });

    return NextResponse.json({
      items,
      stats,
      lastUpdated: analyses?.[0]?.created_at || null,
    });
  } catch (error) {
    logger.error('News API error', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// POST /api/news - Save a news item to saved_news table
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Saves a news item to the saved_news table.
 * Promotes a transient news item from email_analyses to persistent storage.
 *
 * Body:
 * ```json
 * {
 *   "headline": "string",
 *   "detail": "string",
 *   "topics": ["string"],
 *   "dateMentioned": "YYYY-MM-DD" (optional),
 *   "confidence": 0.92,
 *   "emailId": "uuid"
 * }
 * ```
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { headline, detail, topics, dateMentioned, confidence, emailId } = body;

    // Validate required fields
    if (!headline) {
      return NextResponse.json(
        { error: 'Missing required field: headline' },
        { status: 400 }
      );
    }

    logger.info('Saving news item', {
      userId: user.id.substring(0, 8),
      emailId: emailId?.substring(0, 8),
      preview: headline.substring(0, 40),
    });

    const { data, error: insertError } = await supabase
      .from('saved_news')
      .insert({
        user_id: user.id,
        email_id: emailId || null,
        headline,
        detail: detail || null,
        topics: topics || [],
        date_mentioned: dateMentioned || null,
        status: 'saved',
        confidence: confidence || null,
      })
      .select('id')
      .single();

    if (insertError) {
      logger.error('Failed to save news item', { error: insertError.message });
      return NextResponse.json({ error: 'Failed to save news item' }, { status: 500 });
    }

    logger.info('News item saved', { id: data.id });

    return NextResponse.json({ success: true, id: data.id }, { status: 201 });
  } catch (error) {
    logger.error('Save news error', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PATCH /api/news - Update news item status
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Updates the status of a saved news item.
 *
 * Body:
 * ```json
 * {
 *   "id": "uuid",
 *   "status": "new|saved|dismissed|archived"
 * }
 * ```
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { id, status } = body;

    if (!id || !status) {
      return NextResponse.json(
        { error: 'Missing required fields: id, status' },
        { status: 400 }
      );
    }

    const validStatuses = ['new', 'saved', 'dismissed', 'archived'];
    if (!validStatuses.includes(status)) {
      return NextResponse.json(
        { error: `Invalid status. Must be one of: ${validStatuses.join(', ')}` },
        { status: 400 }
      );
    }

    logger.info('Updating news item status', {
      newsId: id.substring(0, 8),
      newStatus: status,
    });

    const { error: updateError } = await supabase
      .from('saved_news')
      .update({
        status,
        updated_at: new Date().toISOString(),
      })
      .eq('id', id)
      .eq('user_id', user.id); // Ownership check

    if (updateError) {
      logger.error('Failed to update news item', { error: updateError.message });
      return NextResponse.json({ error: 'Failed to update news item' }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    logger.error('Update news error', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
