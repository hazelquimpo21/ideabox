/**
 * useIdeas Hook
 *
 * Fetches idea sparks generated from email content and provides
 * actions for saving/dismissing ideas.
 *
 * NEW (Feb 2026): Creative idea generation from email analysis.
 * Ideas are generated by the IdeaSparkAnalyzer and stored in
 * email_analyses.idea_sparks. This hook reads them via the Ideas API.
 *
 * @module hooks/useIdeas
 * @since February 2026
 */

'use client';

import { useState, useEffect, useCallback } from 'react';
import { createLogger } from '@/lib/utils/logger';

const logger = createLogger('useIdeas');

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * A single idea spark from email analysis.
 */
export interface IdeaItem {
  /** The idea itself — 1-2 sentences, specific and actionable */
  idea: string;
  /** Category: social_post, networking, business, content_creation, etc. */
  type: string;
  /** Why this connects to the user's context */
  relevance: string;
  /** Confidence score (0-1) */
  confidence: number;
  /** Source email ID */
  emailId: string;
  /** Source email subject (for context) */
  emailSubject: string | null;
  /** Source email sender name/email */
  emailSender: string | null;
  /** When the email was analyzed (ISO string) */
  analyzedAt: string;
}

/**
 * Statistics about generated ideas.
 */
export interface IdeasStats {
  totalSparks: number;
  savedIdeas: number;
  byType: Record<string, number>;
  avgConfidence: number;
}

/**
 * Options for the hook.
 */
export interface UseIdeasOptions {
  /** Number of emails to check for ideas (default: 10) */
  limit?: number;
  /** Filter by idea type */
  type?: string;
  /** Minimum confidence threshold (default: 0.3) */
  minConfidence?: number;
  /** Auto-refresh interval in ms (0 = disabled, default: 0) */
  refreshInterval?: number;
  /** Skip initial fetch */
  skip?: boolean;
}

/**
 * Return type for the hook.
 */
export interface UseIdeasReturn {
  /** Idea spark items */
  items: IdeaItem[];
  /** Statistics */
  stats: IdeasStats | null;
  /** Loading state */
  isLoading: boolean;
  /** Error if any */
  error: Error | null;
  /** Manually refetch ideas */
  refetch: () => Promise<void>;
  /** Save an idea to the email_ideas table */
  saveIdea: (idea: IdeaItem) => Promise<void>;
  /** Dismiss an idea (remove from list) */
  dismissIdea: (idea: IdeaItem) => void;
}

// ═══════════════════════════════════════════════════════════════════════════════
// HOOK
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Hook to fetch and manage idea sparks.
 *
 * @param options - Configuration options
 * @returns Idea items with loading/error states and actions
 *
 * @example
 * ```tsx
 * const { items, stats, isLoading, saveIdea, dismissIdea } = useIdeas({ limit: 10 });
 *
 * return items.map(idea => (
 *   <IdeaCard
 *     key={`${idea.emailId}-${idea.type}`}
 *     idea={idea}
 *     onSave={() => saveIdea(idea)}
 *     onDismiss={() => dismissIdea(idea)}
 *   />
 * ));
 * ```
 */
export function useIdeas(options: UseIdeasOptions = {}): UseIdeasReturn {
  const {
    limit = 10,
    type,
    minConfidence = 0.3,
    refreshInterval = 0,
    skip = false,
  } = options;

  const [items, setItems] = useState<IdeaItem[]>([]);
  const [stats, setStats] = useState<IdeasStats | null>(null);
  const [isLoading, setIsLoading] = useState(!skip);
  const [error, setError] = useState<Error | null>(null);

  /**
   * Fetch ideas from the API.
   */
  const fetchIdeas = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      logger.debug('Fetching ideas', { limit, type, minConfidence });

      const params = new URLSearchParams({ limit: String(limit) });
      if (type) params.set('type', type);
      if (minConfidence !== 0.3) params.set('min_confidence', String(minConfidence));

      const response = await fetch(`/api/ideas?${params.toString()}`);

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch ideas');
      }

      const result = await response.json();

      setItems(result.items || []);
      setStats(result.stats || null);

      logger.debug('Ideas fetched', {
        sparkCount: result.items?.length ?? 0,
        savedCount: result.stats?.savedIdeas ?? 0,
      });
    } catch (err) {
      const fetchError = err instanceof Error ? err : new Error('Unknown error');
      logger.error('Ideas fetch failed', { error: fetchError.message });
      setError(fetchError);
    } finally {
      setIsLoading(false);
    }
  }, [limit, type, minConfidence]);

  /**
   * Save an idea to the email_ideas table.
   * Removes it from the current spark list (it's now "saved").
   */
  const saveIdea = useCallback(async (idea: IdeaItem) => {
    logger.info('Saving idea', {
      type: idea.type,
      emailId: idea.emailId.substring(0, 8),
      preview: idea.idea.substring(0, 40),
    });

    try {
      const response = await fetch('/api/ideas', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          idea: idea.idea,
          ideaType: idea.type,
          relevance: idea.relevance,
          confidence: idea.confidence,
          emailId: idea.emailId,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to save idea');
      }

      // Remove from spark list and update stats
      setItems(prev => prev.filter(i =>
        !(i.emailId === idea.emailId && i.idea === idea.idea)
      ));
      setStats(prev => prev ? {
        ...prev,
        savedIdeas: prev.savedIdeas + 1,
        totalSparks: prev.totalSparks - 1,
      } : prev);

      logger.success('Idea saved', { type: idea.type });
    } catch (err) {
      logger.error('Save idea failed', {
        error: err instanceof Error ? err.message : 'Unknown error',
      });
      throw err;
    }
  }, []);

  /**
   * Dismiss an idea — removes it from the current view.
   * Does NOT persist the dismissal (sparks regenerate on refresh).
   * For permanent dismissal, save with status='dismissed' via the API.
   */
  const dismissIdea = useCallback((idea: IdeaItem) => {
    logger.debug('Dismissing idea', { type: idea.type });
    setItems(prev => prev.filter(i =>
      !(i.emailId === idea.emailId && i.idea === idea.idea)
    ));
  }, []);

  // Initial fetch
  useEffect(() => {
    if (!skip) {
      fetchIdeas();
    }
  }, [skip, fetchIdeas]);

  // Auto-refresh interval
  useEffect(() => {
    if (refreshInterval > 0 && !skip) {
      const interval = setInterval(fetchIdeas, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [refreshInterval, skip, fetchIdeas]);

  return {
    items,
    stats,
    isLoading,
    error,
    refetch: fetchIdeas,
    saveIdea,
    dismissIdea,
  };
}

export default useIdeas;
