/**
 * useInsights Hook
 *
 * Fetches synthesized insights from email content and provides
 * actions for saving/dismissing insights.
 *
 * NEW (Feb 2026): Insight extraction from newsletter/substantive content.
 * Insights are generated by the InsightExtractorAnalyzer and stored in
 * email_analyses.insight_extraction. This hook reads them via the Insights API.
 *
 * @module hooks/useInsights
 * @since February 2026
 */

'use client';

import { useState, useEffect, useCallback } from 'react';
import { createLogger } from '@/lib/utils/logger';

const logger = createLogger('useInsights');

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * A single insight from email analysis.
 */
export interface InsightItem {
  /** The insight text — 1-2 sentences, synthesized and memorable */
  insight: string;
  /** Category: tip, framework, observation, counterintuitive, trend */
  type: string;
  /** Topic tags for filtering and grouping */
  topics: string[];
  /** Confidence score (0-1) */
  confidence: number;
  /** Source email ID */
  emailId: string;
  /** Source email subject (for context) */
  emailSubject: string | null;
  /** Source email sender name/email */
  emailSender: string | null;
  /** When the email was analyzed (ISO string) */
  analyzedAt: string;
}

/**
 * Statistics about generated insights.
 */
export interface InsightsStats {
  totalInsights: number;
  savedInsights: number;
  byType: Record<string, number>;
  avgConfidence: number;
}

/**
 * Options for the hook.
 */
export interface UseInsightsOptions {
  /** Number of emails to check for insights (default: 10) */
  limit?: number;
  /** Filter by insight type */
  type?: string;
  /** Minimum confidence threshold (default: 0.3) */
  minConfidence?: number;
  /** Auto-refresh interval in ms (0 = disabled, default: 0) */
  refreshInterval?: number;
  /** Skip initial fetch */
  skip?: boolean;
}

/**
 * Return type for the hook.
 */
export interface UseInsightsReturn {
  /** Insight items */
  items: InsightItem[];
  /** Statistics */
  stats: InsightsStats | null;
  /** Loading state */
  isLoading: boolean;
  /** Error if any */
  error: Error | null;
  /** Manually refetch insights */
  refetch: () => Promise<void>;
  /** Save an insight to the saved_insights table */
  saveInsight: (insight: InsightItem) => Promise<void>;
  /** Dismiss an insight (remove from list) */
  dismissInsight: (insight: InsightItem) => void;
}

// ═══════════════════════════════════════════════════════════════════════════════
// HOOK
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Hook to fetch and manage insights from email analysis.
 *
 * @param options - Configuration options
 * @returns Insight items with loading/error states and actions
 *
 * @example
 * ```tsx
 * const { items, stats, isLoading, saveInsight } = useInsights({ limit: 10 });
 *
 * return items.map(insight => (
 *   <InsightCard
 *     key={`${insight.emailId}-${insight.type}`}
 *     insight={insight}
 *     onSave={() => saveInsight(insight)}
 *   />
 * ));
 * ```
 */
export function useInsights(options: UseInsightsOptions = {}): UseInsightsReturn {
  const {
    limit = 10,
    type,
    minConfidence = 0.3,
    refreshInterval = 0,
    skip = false,
  } = options;

  const [items, setItems] = useState<InsightItem[]>([]);
  const [stats, setStats] = useState<InsightsStats | null>(null);
  const [isLoading, setIsLoading] = useState(!skip);
  const [error, setError] = useState<Error | null>(null);

  /**
   * Fetch insights from the API.
   */
  const fetchInsights = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      logger.debug('Fetching insights', { limit, type, minConfidence });

      const params = new URLSearchParams({ limit: String(limit) });
      if (type) params.set('type', type);
      if (minConfidence !== 0.3) params.set('min_confidence', String(minConfidence));

      const response = await fetch(`/api/insights?${params.toString()}`);

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch insights');
      }

      const result = await response.json();

      setItems(result.items || []);
      setStats(result.stats || null);

      logger.debug('Insights fetched', {
        insightCount: result.items?.length ?? 0,
        savedCount: result.stats?.savedInsights ?? 0,
      });
    } catch (err) {
      const fetchError = err instanceof Error ? err : new Error('Unknown error');
      logger.error('Insights fetch failed', { error: fetchError.message });
      setError(fetchError);
    } finally {
      setIsLoading(false);
    }
  }, [limit, type, minConfidence]);

  /**
   * Save an insight to the saved_insights table.
   * Removes it from the current list (it's now "saved").
   */
  const saveInsight = useCallback(async (insight: InsightItem) => {
    logger.info('Saving insight', {
      type: insight.type,
      emailId: insight.emailId.substring(0, 8),
      preview: insight.insight.substring(0, 40),
    });

    try {
      const response = await fetch('/api/insights', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          insight: insight.insight,
          insightType: insight.type,
          topics: insight.topics,
          confidence: insight.confidence,
          emailId: insight.emailId,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to save insight');
      }

      // Remove from list and update stats
      setItems(prev => prev.filter(i =>
        !(i.emailId === insight.emailId && i.insight === insight.insight)
      ));
      setStats(prev => prev ? {
        ...prev,
        savedInsights: prev.savedInsights + 1,
        totalInsights: prev.totalInsights - 1,
      } : prev);

      logger.success('Insight saved', { type: insight.type });
    } catch (err) {
      logger.error('Save insight failed', {
        error: err instanceof Error ? err.message : 'Unknown error',
      });
      throw err;
    }
  }, []);

  /**
   * Dismiss an insight — removes it from the current view.
   * Does NOT persist the dismissal (insights regenerate on refresh).
   */
  const dismissInsight = useCallback((insight: InsightItem) => {
    logger.debug('Dismissing insight', { type: insight.type });
    setItems(prev => prev.filter(i =>
      !(i.emailId === insight.emailId && i.insight === insight.insight)
    ));
  }, []);

  // Initial fetch
  useEffect(() => {
    if (!skip) {
      fetchInsights();
    }
  }, [skip, fetchInsights]);

  // Auto-refresh interval
  useEffect(() => {
    if (refreshInterval > 0 && !skip) {
      const interval = setInterval(fetchInsights, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [refreshInterval, skip, fetchInsights]);

  return {
    items,
    stats,
    isLoading,
    error,
    refetch: fetchInsights,
    saveInsight,
    dismissInsight,
  };
}

export default useInsights;
